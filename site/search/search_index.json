{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Sistemas din\u00e1micos","text":"<p>Un sistema din\u00e1mico es un sistema cuyo estado evoluciona con el tiempo, son modelos de suma importancia en las ciencias. En f\u00edsica, un sistema din\u00e1mico se describe como una part\u00edcula o conjunto de part\u00edculas cuyo estado var\u00eda con el tiempo y, por lo tanto, obedece a ecuaciones diferenciales que implican derivadas temporales.</p> <p>En general, un modelo din\u00e1mico intenta resolver la trayectoria temporal de alguna cantidad f\u00edsica como funci\u00f3n de alg\u00fan generador din\u00e1mico; este \u00faltimo usualmente representado de forma funcional.</p> <p>En algunos casos, podemos modelar la din\u00e1mica de un estado gen\u00e9rico  mediante la ecuaci\u00f3n din\u00e1mica  sujeta a la condici\u00f3n inicial  </p> <p>Donde,  corresponde a la variable temporal; y  a un estado del sistema. Este estado puede ser representado mediante diferentes objetos matem\u00e1ticos: desde cantidades escalares hasta matrices que representan cierto operador lineal.</p> <p>El problema din\u00e1mico descrito anteriormente es usualmente conocido en el campo de las matem\u00e1ticas aplicadas como problema de condici\u00f3n inicial. </p>"},{"location":"explanation.html","title":"Metodo numerico Runge-Kutta de orden 4","text":"<p>En an\u00e1lisis num\u00e9rico, los m\u00e9todos de Runge-Kutta son un conjunto de m\u00e9todos gen\u00e9ricos iterativos, expl\u00edcitos e impl\u00edcitos, de resoluci\u00f3n num\u00e9rica de ecuaciones diferenciales ordinarias, concretamente, del problema de valor inicial. Este conjunto de m\u00e9todos fue inicialmente desarrollado alrededor del a\u00f1o 1900 por los matem\u00e1ticos alemanes Carl David Tolm\u00e9 Runge y Martin Wilhelm Kutta.</p> <p>Restringiremos nuestro estudio al m\u00e9todo Runge-Kutta de orden 4 (RK4). Habiendo definido el problema:  sujeto a , se procede a ir perturbando el estado \"presente\"  de forma iterativa, con el objetivo de encontrar el estado siguiente ():</p> <p> </p> <p>donde:</p> <p> </p> <p>Aca,  es el paso por iteraci\u00f3n, o lo que es lo mismo, el incremento  entre los sucesivos puntos  y . </p>"},{"location":"reference.html","title":"Referencia","text":"<p>A continuacion se muestra la documentacion de las funciones refentes a la implementacion del metodo RK4.</p>"},{"location":"reference.html#src.RK4.dyn_generator","title":"<code>dyn_generator(oper=2, state=3)</code>","text":"<p>Se refiere a la funcion que genera la din\u00e1mica del problema .</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; oOper = np.array([[0, 1], [1, 0]])\n&gt;&gt;&gt; yInit = np.array([[1, 0], [0, 0]])\n&gt;&gt;&gt; dyn_generator(oOper,yInit)\n[[0.-0.j 0.+1.j]\n [0.-1.j 0.-0.j]]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>oper</code> <code>array_object</code> <p>Primer argumento</p> <code>2</code> <code>state</code> <code>array_object</code> <p>Segundo argumento</p> <code>3</code> <p>Returns:</p> Name Type Description <code>array_object</code> <p>Devuelve el valor de la funcion evaluada en oper y state.</p> Source code in <code>src/RK4.py</code> <pre><code>def dyn_generator(oper=2, state=3):\n    \"\"\"Se refiere a la funcion que genera la din\u00e1mica del problema \\(f(t,\\mathbf{y}) = -i[\\mathbf{O}, \\mathbf{y}(t)]\\).\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; oOper = np.array([[0, 1], [1, 0]])\n        &gt;&gt;&gt; yInit = np.array([[1, 0], [0, 0]])\n        &gt;&gt;&gt; dyn_generator(oOper,yInit)\n        [[0.-0.j 0.+1.j]\n         [0.-1.j 0.-0.j]]\n\n    Args:\n        oper (array_object): Primer argumento\n        state (array_object): Segundo argumento\n\n    Returns:\n        array_object: Devuelve el valor de la funcion evaluada en oper y state.\n\n    \"\"\"\n    return -1.0j*(np.dot(oper,state)-np.dot(state,oper))\n</code></pre>"},{"location":"tutorials.html","title":"Ejemplo de uso","text":"<p>En el presente documento se mostrara un ejemplo de uso del codigo de implementacion del metodo RK4, este se encuentra en Referencia.</p> <p>Se tiene que la din\u00e1mica del problema depende intr\u00ednsicamente del operador . De forma que se escoge el siguiente:  </p> <p>Dicho operador puede tener distintos significados f\u00edsicos dependiendo del problema din\u00e1mico en cuesti\u00f3n. Y su implementacion en python se veria de la siquiente manera: <code>oOper = np.array([[0, 1], [1, 0]])</code> (tomese en cuenta que<code>np</code> representa un acronimo para invocar la funcionalidad modulo <code>numpy</code>).</p> <p>Ademas, para el estado inicial se utilizara:  </p> <p>Equivalentemente, en python: <code>yInit = np.array([[1, 0], [0, 0]])</code>.</p> <p>Ahora, se procede a inicializar un arreglo de valores temporales y definir , que como  se menciono anteriormente, es el paso por iteraci\u00f3n:</p> <pre><code>times = np.linspace(0.0,10.0, num=50)     \nh=times[1]-times[0]\n</code></pre> <p>Una buena practica es realizar un \"deep copy\" de un objeto sobre el que vamos a sobreescribir mas adelante, este es el caso de <code>yInit</code>, por lo tanto, se usara <code>copy()</code>, tambien del modulo <code>numpy</code>:</p> <p><code>yCopy = yInit.copy()</code></p> <p>Con esto hecho, se llamara de manera iterativa la rutina <code>rk4()</code>. Calculando el operador del estado del sistema  a trav\u00e9s del tiempo. Para visulizar su cambio de una forma clara, se va a guardar la entrada  y  de la matriz  para posteriormente graficarlas. </p> <p>De manera que, se inicializara dos arreglos destinados a contener dichas entradas con valores iniciales de cero. Se utilizara el mismo tama\u00f1o del arreglo que contiene la variable independiente temporal:</p> <pre><code>stateQuant00 = np.zeros(times.size)      \nstateQuant11 = np.zeros(times.size)\n</code></pre> <p>Y ademas, se crea una rutina que realiza la evolucion temporal:</p> <pre><code>for tt in range(times.size):\n    stateQuant00[tt]=yInit[0,0].real\n    stateQuant11[tt]=yInit[1,1].real\n\n    yInit=rk4(dyn_generator,oOper,yInit,h)\n</code></pre> <p>Finalmente, con ayuda de <code>matplotlib</code> (<code>import matplotlib.pyplot as plt</code>) se grafican la entrada  y  de la matriz  con respecto al arreglo de valores temporales <code>times</code>:</p> <pre><code>plt.style.use('_mpl-gallery')\n\nx = times\ny = stateQuant00\ny2 = stateQuant11\n\nplt.plot(x, y, 'g.-',linewidth=1.5)\nplt.plot(x, y2 , '.-', linewidth=1.5)\n\nplt.title(\"Evolucion temporal de las entradas (0,0) y (1,1) del estado estudiado.\")\nplt.xlabel(\"Tiempo\")\nplt.ylabel(\"Entradas del estado\")\nplt.legend([\"Entrada (0,0)\", \"Entrada (1,1)\"], loc=\"upper left\",bbox_to_anchor=(1.05, 0.75), ncol=1)\n\nplt.savefig('Evolucion de las entradas.png')\n</code></pre> <p>El grafico resultante se muestra a continuacion:</p>"}]}