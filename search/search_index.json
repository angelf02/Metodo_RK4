{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Sistemas din\u00e1micos","text":"<p>Un sistema din\u00e1mico es un sistema cuyo estado evoluciona con el tiempo, son modelos de suma importancia en las ciencias. En f\u00edsica, un sistema din\u00e1mico se describe como una part\u00edcula o conjunto de part\u00edculas cuyo estado var\u00eda con el tiempo y, por lo tanto, obedece a ecuaciones diferenciales que implican derivadas temporales.</p> <p>En general, un modelo din\u00e1mico intenta resolver la trayectoria temporal de alguna cantidad f\u00edsica como funci\u00f3n de alg\u00fan generador din\u00e1mico; este \u00faltimo usualmente representado de forma funcional.</p> <p>En algunos casos, podemos modelar la din\u00e1mica de un estado gen\u00e9rico  mediante la ecuaci\u00f3n din\u00e1mica  sujeta a la condici\u00f3n inicial  </p> <p>Donde,  corresponde a la variable temporal; y  a un estado del sistema. Este estado puede ser representado mediante diferentes objetos matem\u00e1ticos: desde cantidades escalares hasta matrices que representan cierto operador lineal.</p> <p>El problema din\u00e1mico descrito anteriormente es usualmente conocido en el campo de las matem\u00e1ticas aplicadas como problema de condici\u00f3n inicial. </p>"},{"location":"explanation.html","title":"M\u00e9todo num\u00e9rico Runge-Kutta de orden 4","text":"<p>En an\u00e1lisis num\u00e9rico, los m\u00e9todos de Runge-Kutta son un conjunto de m\u00e9todos gen\u00e9ricos iterativos, expl\u00edcitos e impl\u00edcitos, de resoluci\u00f3n num\u00e9rica de ecuaciones diferenciales ordinarias, concretamente, del problema de valor inicial. Este conjunto de m\u00e9todos fue inicialmente desarrollado alrededor del a\u00f1o 1900 por los matem\u00e1ticos alemanes Carl David Tolm\u00e9 Runge y Martin Wilhelm Kutta.</p> <p>Restringimos nuestro estudio al m\u00e9todo Runge-Kutta de orden 4 (RK4). Habiendo definido el problema:  sujeto a , se procede a ir perturbando el estado \"presente\"  de forma iterativa, con el objetivo de encontrar el estado siguiente ():</p> <p> </p> <p>donde:</p> <p> </p> <p>Ac\u00e1,  es el paso por iteraci\u00f3n, o lo que es lo mismo, el incremento  entre los sucesivos puntos  y .</p>"},{"location":"reference.html","title":"Referencia","text":"<p>A continuaci\u00f3n se muestra la documentaci\u00f3n de las funciones referentes a la implementaci\u00f3n del m\u00e9todo RK4.</p>"},{"location":"reference.html#src.RK4.dyn_generator","title":"<code>dyn_generator(oper, state)</code>","text":"<p>Se refiere a la funci\u00f3n que genera la din\u00e1mica del problema.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; oOper = np.array([[0, 1], [1, 0]])\n&gt;&gt;&gt; yInit = np.array([[1, 0], [0, 0]])\n&gt;&gt;&gt; dyn_generator(oOper,yInit)\n[[0.-0.j 0.+1.j]\n [0.-1.j 0.-0.j]]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>oper</code> <code>array_object</code> <p>Primer argumento, especifica al operador deseado</p> required <code>state</code> <code>array_object</code> <p>Segundo argumento, especifica un estado</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>array_object</code> <p>Devuelve el valor de la funci\u00f3n evaluada en oper y state.</p> Source code in <code>src/RK4.py</code> <pre><code>def dyn_generator(oper, state):\n    \"\"\"Se refiere a la funci\u00f3n que genera la din\u00e1mica del problema.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; oOper = np.array([[0, 1], [1, 0]])\n        &gt;&gt;&gt; yInit = np.array([[1, 0], [0, 0]])\n        &gt;&gt;&gt; dyn_generator(oOper,yInit)\n        [[0.-0.j 0.+1.j]\n         [0.-1.j 0.-0.j]]\n\n    Args:\n        oper (array_object): Primer argumento, especifica al operador deseado\n        state (array_object): Segundo argumento, especifica un estado\n\n    Returns:\n        out (array_object): Devuelve el valor de la funci\u00f3n evaluada en oper y state.\n\n    \"\"\"\n    return -1.0j*(np.dot(oper,state)-np.dot(state,oper))\n</code></pre>"},{"location":"reference.html#src.RK4.rk4","title":"<code>rk4(func, oper, state, h)</code>","text":"<p>Se refiere a la funci\u00f3n que realiza la operaci\u00f3n din\u00e1mica (implementaci\u00f3n de RK4).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rk4(dyn_generator,oOper,yInit,0.1)\n[[0.99003333+0.j         0.        +0.09933333j]\n [0.        -0.09933333j 0.00996667+0.j        ]]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>function</code> <p>Primer argumento, especifica la funci\u00f3n que genera la din\u00e1mica</p> required <code>oper</code> <code>array_object</code> <p>Segundo argumento, especifica al operador deseado</p> required <code>state</code> <code>array_object</code> <p>Tercer argumento, especifica un estado</p> required <code>h</code> <code>float</code> <p>Cuarto argumento, se refiere al paso temporal deseado</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>array_object</code> <p>Devuelve el estado siguiente.</p> Source code in <code>src/RK4.py</code> <pre><code>def rk4(func, oper, state, h):\n    \"\"\"Se refiere a la funci\u00f3n que realiza la operaci\u00f3n din\u00e1mica (implementaci\u00f3n de RK4).\n\n    Examples:\n        &gt;&gt;&gt; rk4(dyn_generator,oOper,yInit,0.1)\n        [[0.99003333+0.j         0.        +0.09933333j]\n         [0.        -0.09933333j 0.00996667+0.j        ]]\n\n    Args:\n        func (function): Primer argumento, especifica la funci\u00f3n que genera la din\u00e1mica\n        oper (array_object): Segundo argumento, especifica al operador deseado\n        state (array_object): Tercer argumento, especifica un estado\n        h (float): Cuarto argumento, se refiere al paso temporal deseado\n\n    Returns:\n        out (array_object): Devuelve el estado siguiente.\n\n    \"\"\"\n    k1=h*func(oper,state)\n    k2=h*func(oper,state+k1/2)\n    k3=h*func(oper,state+k2/2)\n    k4=h*func(oper,state+k3)\n    return state+(1/6)*(k1+2*k2+2*k3+k4)\n</code></pre>"},{"location":"tutorials.html","title":"Ejemplo de uso","text":"<p>En el presente documento se mostrar\u00e1 un ejemplo de uso del c\u00f3digo de implementaci\u00f3n del m\u00e9todo RK4, este se encuentra en Referencia.</p> <p>Se tiene que la din\u00e1mica del problema depende intr\u00ednsecamente del operador . De forma que se escoge el siguiente:  </p> <p>Dicho operador puede tener distintos significados f\u00edsicos dependiendo del problema din\u00e1mico en cuesti\u00f3n. Y su implementaci\u00f3n en python se ver\u00eda de la siguiente manera: <code>oOper = np.array([[0, 1], [1, 0]])</code> (t\u00f3mese en cuenta que<code>np</code> representa un acr\u00f3nimo para invocar la funcionalidad m\u00f3dulo <code>numpy</code>).</p> <p>Adem\u00e1s, para el estado inicial se utilizar\u00e1:  </p> <p>Equivalentemente, en python: <code>yInit = np.array([[1, 0], [0, 0]])</code>.</p> <p>Ahora, se procede a inicializar un arreglo de valores temporales y definir , que como  se mencion\u00f3 anteriormente, es el paso por iteraci\u00f3n:</p> <pre><code>times = np.linspace(0.0,10.0, num=50)     \nh=times[1]-times[0]\n</code></pre> <p>Una buena pr\u00e1ctica es realizar un \"deep copy\" de un objeto sobre el que vamos a sobreescribir m\u00e1s adelante, este es el caso de <code>yInit</code>, por lo tanto, se usar\u00e1 <code>copy()</code>, tambi\u00e9n del m\u00f3dulo <code>numpy</code>:</p> <p><code>yCopy = yInit.copy()</code></p> <p>Con esto hecho, se llamar\u00e1 de manera iterativa la rutina <code>rk4()</code>. Calculando as\u00ed el operador que genera la din\u00e1mica del sistema, u operador del estado del sistema</p> <p> </p> <p>a trav\u00e9s del tiempo. Es importante notar que  no depende expl\u00edcitamente de , sino, del operador y el estado; siendo en realidad este \u00faltimo el que cuenta con una dependencia temporal expl\u00edcita.</p> <p>Para visualizar su cambio de una forma clara, se va a guardar la entrada  y  de la matriz  para posteriormente graficarlas.</p> <p>De manera que, se inicializar\u00e1 dos arreglos destinados a contener dichas entradas con valores iniciales de cero. Se utilizar\u00e1 el mismo tama\u00f1o del arreglo que contiene la variable independiente temporal:</p> <pre><code>stateQuant00 = np.zeros(times.size)      \nstateQuant11 = np.zeros(times.size)\n</code></pre> <p>Y adem\u00e1s, se crea una rutina que almacena los valores deseados, y realiza la evoluci\u00f3n temporal:</p> <pre><code>for tt in range(times.size):\n    stateQuant00[tt]=yInit[0,0].real\n    stateQuant11[tt]=yInit[1,1].real\n\n    yInit=rk4(dyn_generator,oOper,yInit,h)\n</code></pre> <p>Finalmente, con ayuda de <code>matplotlib</code> (<code>import matplotlib.pyplot as plt</code>) se grafican la entrada  y  de la matriz  con respecto al arreglo de valores temporales <code>times</code>:</p> <pre><code>plt.style.use('_mpl-gallery')\n\nx = times\ny = stateQuant00\ny2 = stateQuant11\n\nplt.plot(x, y, 'g.-',linewidth=1.5)\nplt.plot(x, y2 , '.-', linewidth=1.5)\n\nplt.title(\"Evolucion temporal de las entradas (0,0) y (1,1) del estado estudiado.\")\nplt.xlabel(\"Tiempo\")\nplt.ylabel(\"Entradas del estado\")\nplt.legend([\"Entrada (0,0)\", \"Entrada (1,1)\"], loc=\"upper left\",bbox_to_anchor=(1.05, 0.75), ncol=1)\n\nplt.savefig('Evolucion de las entradas.png')\n</code></pre> <p>El gr\u00e1fico resultante se muestra a continuaci\u00f3n:</p>"}]}